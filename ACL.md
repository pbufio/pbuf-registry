
# Access Control (ACL), Tokens, and Authorization

This document describes the **implemented** authentication/authorization pieces in this branch (compared to `main`) and how to use them.

## What changed vs `main`

This branch adds the foundations for role-based access control:

### Database

- `migrations/20251226133900_enable_pgcrypto.sql` — enables `pgcrypto` (required for bcrypt hashing + `crypt()` verification).
- `migrations/20251226134000_users_bots.sql` — `users` table (users/bots, bcrypt-hashed tokens).
- `migrations/20251226134100_acl.sql` — `acl` table (per-user permissions per module, including wildcard `*`).

### Domain + repositories

- `internal/model/user.go` — `UserType` (`user`/`bot`), `Permission` (`read`/`write`/`admin`), `User`, `ACLEntry`.
- `internal/data/users.go` — `UserRepository` with pgcrypto-backed token verification.
- `internal/data/acl.go` — `ACLRepository` with wildcard + permission hierarchy.

### Middleware

- `internal/middleware/auth.go`
  - existing modes: `NewNoAuth`, `NewStaticTokenAuth`
  - new: `NewACLAuth` (admin token OR user/bot token from DB; supports optional `Bearer` prefix).
- `internal/middleware/authz.go` — new authorization middleware (`NewAuthorizationMiddleware`) that maps RPC operations to required permissions and checks them via `ACLRepository.CheckPermission`.

### Tests

- `internal/data/users_test.go` — full CRUD + pgcrypto token verification behavior.
- `internal/data/acl_test.go` — permission hierarchy, wildcard behavior, revoke/delete/cascade.
- `internal/middleware/auth_integration_test.go` — integration tests for `NewACLAuth` against a real Postgres (pgcrypto).
- `internal/middleware/authz_request_integration_test.go` — request-level gRPC integration tests for `NewAuthorizationMiddleware` + `NewACLAuth`.

## Concepts

### Actors

- **Admin**: identified by the **static token** (`SERVER_STATIC_TOKEN`).
- **User/Bot**: stored in DB (`users` table) and authenticated via a **plaintext token** that is verified using pgcrypto (`crypt()`), not by comparing against stored plaintext.

### Token format

Tokens generated by the server follow:

```
pbuf_<type>_<base64url(random 32 bytes)>
```

Examples:

- `pbuf_user_...`
- `pbuf_bot_...`

### Token storage & verification (pgcrypto)

- On insert/update, tokens are stored as bcrypt hashes:
  - `crypt($token, gen_salt('bf'))`
- Verification uses:
  - `(token = crypt($provided, token)) = true`
- Inactive users are filtered out during token lookup:
  - `... AND is_active = true`

See `internal/data/users.go:GetUserByToken`.

### Permissions

Permission levels are:

- `read`
- `write`
- `admin`

They are hierarchical:

```
admin > write > read
```

Permissions are stored per `(user_id, module_name)`.

- `module_name` can be a concrete module name
- or `*` (wildcard) meaning “applies to all modules”

Resolution rules (implemented in `ACLRepository.CheckPermission`):

1. Check **exact** `(user_id, module_name)`.
2. If not found, check wildcard `(user_id, '*')`.
3. A specific module grant effectively “overrides” the wildcard because it is checked first.

## Authentication middleware

All auth middleware in this repo reads the **`Authorization`** header (Kratos request header). What is considered a valid value depends on the auth mode.

### 1) No auth

- Middleware: `middleware.NewNoAuth()`
- Behavior: allows every request.

### 2) Static token auth (existing)

- Middleware: `middleware.NewStaticTokenAuth(token)`
- Behavior: compares header value with the configured token **exactly**.
  - Note: this middleware does **not** parse `Bearer ...`.
- Error on mismatch: `jwt.ErrTokenInvalid`.

### 3) ACL-aware auth (new)

- Middleware: `middleware.NewACLAuth(adminToken, userRepo, logger)`
- Behavior:
  1. Reads `Authorization` header.
  2. Accepts either:
     - raw token: `Authorization: <token>`
     - bearer token: `Authorization: Bearer <token>`
  3. If token matches `adminToken`:
     - marks request as admin (`middleware.IsAdmin(ctx) == true`).
  4. Otherwise, attempts DB lookup via `UserRepository.GetUserByToken`:
     - if found, stores `*model.User` in context (`middleware.GetUserFromContext`).
     - if not found / inactive, rejects.

Errors:

- Missing/invalid token: `jwt.ErrTokenInvalid`
- Wrong context (no Kratos server context): `jwt.ErrWrongContext`

## Authorization middleware (new)

Middleware: `middleware.NewAuthorizationMiddleware(aclRepo, logger)`

High-level behavior:

1. If request is admin (`middleware.IsAdmin(ctx)`), it is always allowed.
2. If there is no user in context (`middleware.GetUserFromContext(ctx)` returns false), the middleware **does not enforce ACL** and passes through.
   - This is intentional so you can combine it with other auth strategies.
3. Otherwise, it determines the required permission for the called operation and verifies it via:
   - `ACLRepository.CheckPermission(ctx, user.ID, moduleName, requiredPermission)`

On failure it returns a Kratos error:

- `middleware.ErrPermissionDenied` (`Forbidden`, reason `PERMISSION_DENIED`)

### RPC → permission mapping

Implemented in `internal/middleware/authz.go:getRequiredPermission`.

#### UserService

- Any operation containing `/UserService/` requires:
  - `admin` permission on module `*` (or admin token bypass).

#### Registry service

Read operations require `read`:

- `ListModules`
- `GetModule`
- `PullModule`
- `GetModuleDependencies`

Write operations require `write`:

- `RegisterModule`
- `PushModule`

Admin operations require `admin`:

- `DeleteModule`
- `DeleteModuleTag`

### How module name is determined

The middleware attempts to extract module name from the request payload:

- If request implements `GetModuleName() string` → used.
- Else if request implements `GetName() string` → used.
- Else it falls back to wildcard `*`.

See `internal/middleware/authz.go:extractModuleName`.

## User management API surface

The protobuf API definition is in:

- `api/pbuf-registry/v1/users.proto`

It defines `UserService` with HTTP annotations under `/v1/users...` (create/list/get/update/delete/regenerate-token, and permission grant/revoke/list).

Note: server-side wiring (registration of the generated `UserService` handlers) depends on application composition. When enabling the feature end-to-end, ensure your gRPC/HTTP server registers the generated service handlers and that your middleware chain includes ACL auth + authorization.

## How to enable ACL auth + authorization in servers

The ACL stack can be enabled via config.

### Configuration

1) Set the admin token (used as the **admin bypass** token):

```bash
export SERVER_STATIC_TOKEN='your-admin-token'
```

2) Enable ACL auth for the desired transports:

```yaml
server:
  grpc:
    auth:
      enabled: true
      type: acl
  http:
    auth:
      enabled: true
      type: acl
```

When `type: acl` is enabled, the server middleware chain is:

1. `NewACLAuth(...).NewAuthMiddleware()`
2. `NewAuthorizationMiddleware(...)`

Order matters: auth first, then authorization.

### gRPC (Kratos)

```text
auth := middleware.NewACLAuth(adminToken, userRepo, logger)

grpc.NewServer(
  grpc.Middleware(
    auth.NewAuthMiddleware(),
    middleware.NewAuthorizationMiddleware(aclRepo, logger),
  ),
)
```

### HTTP (Kratos)

```text
auth := middleware.NewACLAuth(adminToken, userRepo, logger)

http.NewServer(
  http.Middleware(
    auth.NewAuthMiddleware(),
    middleware.NewAuthorizationMiddleware(aclRepo, logger),
  ),
)
```

## Usage examples

### Admin token

With ACL auth, both formats work:

```
Authorization: <admin-token>
Authorization: Bearer <admin-token>
```

### User/Bot token

```
Authorization: <user-token>
Authorization: Bearer <user-token>
```

## Test coverage

### Prerequisites

Tests spin up Postgres via `test_utils.NewPostgreSQLContainer(...)`. You need a working Docker environment.

### Run all tests

```bash
go test ./...
```

### Focused packages

```bash
go test ./internal/data -run Test_userRepository
go test ./internal/data -run Test_aclRepository
go test ./internal/middleware -run Test_aclAuth
```

### Coverage matrix (what is verified)

#### `internal/data/users_test.go`

- Create user/bot; duplicate name rejection.
- Get by ID / name; not-found behavior (`ErrUserNotFound`).
- Token verification via pgcrypto:
  - valid plaintext token matches bcrypt-hash in DB
  - invalid token returns `ErrUserNotFound`
  - inactive users are not returned by token lookup
- Update behavior:
  - name / is_active changes
  - token rotation: old token no longer matches; new token matches after reactivation
- List pagination (`limit`/`offset`).
- Deactivate/reactivate (`SetUserActive`).
- Delete behavior and not-found cases.

#### `internal/data/acl_test.go`

- Grant permissions for specific module and wildcard `*`.
- Upsert behavior (grant updates existing entry).
- List user permissions.
- Permission hierarchy (`admin > write > read`).
- Wildcard semantics:
  - wildcard write grants write+read but not admin
  - specific module grants are checked before wildcard.
- Revoke behavior and `ErrPermissionNotFound`.
- Delete all permissions for a user.
- Cascade delete of ACL entries when user is deleted (FK `ON DELETE CASCADE`).

#### `internal/middleware/auth_integration_test.go`

- `NewACLAuth` accepts admin token with and without `Bearer ` prefix.
- `NewACLAuth` authenticates user/bot tokens via DB (pgcrypto) and stores `*model.User` in context.
- Inactive user token is rejected.
- Context helper functions:
  - `GetUserFromContext` returns (nil,false) when absent
  - `IsAdmin` reflects the admin flag
- Calling auth middleware without server context returns `jwt.ErrWrongContext`.

#### `internal/middleware/authz_request_integration_test.go`

- Starts a real **Kratos gRPC server** over an in-memory listener and performs real gRPC requests.
- Verifies authorization is enforced **per request** for authenticated users/bots (via `NewACLAuth` user context):
  - missing token → unauthenticated
  - no ACL entries → denied for read/write
  - wildcard `read` allows `GetModule` but denies `RegisterModule`
  - module-specific `write` allows `RegisterModule` only for that module
  - specific module entry overrides wildcard (checked first)
  - admin token bypass allows admin operations